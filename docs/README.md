# 기능 구현 목록

---

### 0. Application
### 1. Controller
#### - Computer
#### - Error
#### - User
### 2. Model
#### - Data
#### - Game
### 3. View 
#### - Output

---

## Application
_전체 애플리케이션의 시작을 명령한다_
###### 시작 기능

---

## Controller
_컴퓨터, 유저, 에러 패키지를 소유한다_
<br>
_게임에 필요한 숫자 생성과 관련된 기능을 메인으로 주관하며 입력 및 생성 관련 오류를 처리한다_
### 1. Computer
#### 1) 랜덤 숫자 생성 로직 
###### 1~9까지의 난수 생성 기능
###### 중복 제어 기능 
###### 반복문을 통한 3자리 난수 완성 기능 
##### 2) 생성된 숫자를 model로 넘겨주는 기능 

<br>

### 2. User
#### 1) 입력 로직
###### 콘솔창을 통한 입력
#### 2) 입력된 숫자를 model로 넘겨주는 기능 

<br>

### 3. Error
#### 1) 컴퓨터 생성 숫자에 대한 에러 검증
###### 3자리수 숫자 조건에 대한 검증
###### 중복 검증 및 중복 설정 여부에 따른 룰 처리 
#### 2) 유저 입력 숫자에 대한 에러 검증
###### 추측용 숫자 입력시 3자리수 조건에 대한 검증
###### 추측용 숫자 입력시 중복 검증 및 중복 설정 여부에 따른 룰 처리
###### 지속 및 종료 의도 숫자 입력시 제시 외 문자 입력 검증 

<br>

### 4. Setup
###### Enum 클래스로서 유저 메시지, 스트라이크/볼/낫싱 메시지, 입력 및 기타 룰을 규정

---

## Model
_데이터, 게임 패키지를 소유한다_
<br>
_데이터 패키지는 유저 입력 숫자와 컴퓨터 생성 숫자를 게임 로직을 위해 가공한다_
<br>
_게임 패키지의 주된 기능은 유저와 컴퓨터 간의 숫자를 비교하며 결과값을 산출하는 것이다_
### 1. Data
#### 1) 컴퓨터 생성 숫자 처리 로직
###### 생성된 숫자를 인덱스와 함께 맵에 저장 기능
#### 2) 유저 입력 숫자 처리 로직
###### 입력받은 숫자를 인덱스와 함께 맵에 저장 기능
#### 3) 데이터 리턴 
###### 자료구조에 저정한 숫자 데이터를 game으로 넘겨주는 기능

<br>

### 2. Game 
#### 1) Calculation
###### 게임 로직의 핵심인 유저 숫자와 컴퓨터 숫자를 비교하는 기능
#### 2) Game 
###### 시작 - 라운드 - 종료 or 지속 기능 수행 
#### 3) Referee
###### Calculation에서 수행한 비교를 판단하는 기능 
- 스트라이크, 볼 집계
- 결과 출력용 메시지 생성
- 유저의 승리 여부 판단
#### 4) Rule
###### 게임의 룰을 결정하는 기능 
- 스트라이크, 볼, 낫싱을 정의 
- 유저의 승리 조건 정의

---

## View 
_아웃풋 패키지를 소유한다_
_애플리케이션 전체의 출력을 담당한다_
<br>
#### 1) Output
###### 출력 메시지를 콘솔 창으로 내보내는 기능 

<br>

---


-----------------------------------------

#### 설계의 쟁점 
설계 포인트 1 : <br>
게임을 진행하는 과정에서 computer 숫자와 idx, user의 숫자와 idx 두가지 정보는 <br>쌍으로 처리되어 비교해야 하는 점에 따라 효율적인 데이터 저장 및 처리를 고민한다.


설계 포인트 2 : <br>
1번에 따라 비교 로직에서 for 문이 중첩이 되는 현상에 대한 허용치를 고민한다.<br>
for문의 중첩을 지양하고 설계하는 방법을 고민한다.


설계 포인트 3: <br>
1번 2번에 대한 답으로 쌍으로 주어지는 정보를 리스트에서 for문을 통해 추출하면서 비교 로직을 수행하는 방법이 있고 <br>
미리 정보를 다 추출한 뒤 map으로 저장하고 그후에 비교 로직을 수행하는 방법이 있다. <br>
본 설계에서는 두 번째 방식을 사용하였으나, 클래스가 많아지고 여러 경로를 거쳐야 하는 문제가 발생한다. 

설계 포인트 4: <br>
쌍으로 주어지는 숫자를 전처리하는 클래스는 게임클래스가 바람직할까 각각의 클래스가 바람직할까에 대한 고민이 필요하다. <br>
본 설계에서는 v1에서 각각의 클래스로 구현하였다가 v2에서 게임 클래스의 data 클래스를 만들어 처리하는 것으로 변경하였다.

---

#### 구현의 쟁점 
구현 애로사항 1 : <br>
test 수행시 void 메서드의 println 테스트 하는 법을 (외부 라이브러리 사용 없이) 찾지 못하였으므로 추후 과제로 남겨둔다. <br>
한편으로는 출력 메시지를 반드시 테스트를 통해 확인하여야 하는가에 대한 고민은 필요해보인다.

구현 애로사항 2 : <br> 프로그램 요구사항으로 제시되지는 않지만 예시의 샘플로 주어지는 특정 기능들은 <br>
상수로써 불변하는 고정 값을 가지도록 요구되고 있다. <br>
이러한 것들을 enum 클래스에서 별도로 관리하는 것의 효율성을 고민해 볼 필요가 있다. <br>
특히 쌍으로 존재하는 것들에 대해서 쌍의 형태로 관리를 하면서 이를 이용하는 방식을 구현한다면 <br>
보다 용이한 코드 구현이 될 것이라 생각된다. <br>
하지만 구체적인 구현 방법에 있어서 어려움이 있으므로 추후 과제로 남겨둔다.

---

#### 리팩토링의 쟁점
처음 설계에서는 User, Computer, Game, Setup 으로 구분된 클래스를 패키지화 하였다. <br>
이와 같이 분화할 경우 한 클래스가 너무 비대해지는 문제가 발생하고, <br> 
같은 클래스에서 여러 기능의 중첩 현상이 발생하는 문제가 발생했다. <br>
따라서 다시 상위 계층인 Model, View, Controller 패키지로 분화할 필요성을 느껴 현재와 같은 설계로 리팩토링하였다. <br>
하지만 이 설계 역시 완벽한 설계는 아니라고 느껴 더 좋은 방식으로 분화하는 방법을 고민해 볼 필요가 있다. 
